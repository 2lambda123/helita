{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Helita \u00b6 Helita is a Python library for solar physics focused on interfacing with code and projects from the Institute of Theoretical Astrophysics (ITA) and the Rosseland Centre for Solar Physics (RoCS) at the University of Oslo . The name comes from Helios + ITA. What is in helita? \u00b6 Helita has the following packages: io : read/write files of different formats obs : a few modules to work with solar observations (mostly Hinode and IRIS) sim : modules to read/write and interact with input/output from simulations and radiative transfer codes utils : miscellaneous utilities, mostly mathematical modules such as curve fitting, interpolation, signal processing vis : visualisation modules, mostly working only in Jupyter.","title":"Helita"},{"location":"#helita","text":"Helita is a Python library for solar physics focused on interfacing with code and projects from the Institute of Theoretical Astrophysics (ITA) and the Rosseland Centre for Solar Physics (RoCS) at the University of Oslo . The name comes from Helios + ITA.","title":"Helita"},{"location":"#what-is-in-helita","text":"Helita has the following packages: io : read/write files of different formats obs : a few modules to work with solar observations (mostly Hinode and IRIS) sim : modules to read/write and interact with input/output from simulations and radiative transfer codes utils : miscellaneous utilities, mostly mathematical modules such as curve fitting, interpolation, signal processing vis : visualisation modules, mostly working only in Jupyter.","title":"What is in helita?"},{"location":"install/","text":"Installation \u00b6 Helita needs Python 3.4.x or higher, use of Python 2.x is discouraged . Helita relies on several standard scientific python libraries. Here is a list of required and optional (not all functions will work) packages: Required Optional astropy cython NumPy numba SciPy bqplot xarray ipywidgets h5py matplotlib tqdm specutils Many of these should be installed when astropy is installed. All of the above Python packages are available through Anaconda , and that is the recommended way of setting up your Python distribution. Compiled modules Some helita modules are written in C and Fortran. To use them, you need to have respective compilers available in your system before you try to install helita (see below for help with compilers). The Fortran modules are optional, and most of helita works without them, but the C modules are not. You need a C compiler to install helita! Install from source \u00b6 To install helita you need to clone the repository (or download a zip version if you don't have git) and then install with python: git clone https://github.com/ITA-solar/helita.git cd helita python setup.py install Non-root install \u00b6 If you don't have write permission to your Python packages directory, use the following option with setup.py : python setup.py install --user This will install helita under your home directory (typically ~/.local ). Developer install \u00b6 If you want to install helita but also actively change the code or contribute to its development, it is recommended that you do a developer install instead: python setup.py develop This will set up the package such as the source files used are from the git repository that you cloned (only a link to it is placed on the Python packages directory). Can also be combined with the --user flag for local installs. Installing with different C or Fortran compilers \u00b6 The procedure above will compile the C and Fortran modules using the default gcc/gfortran compilers. It will fail if at least a C compiler is not available in the system. If you want to use a different compiler, please use setup.py with the --compiler=xxx and/or --fcompiler=yyy options, where xxx , yyy are C and Fortran compiler families (names depend on system). To check which Fortran compilers are available in your system, you can run: python setup.py build --help-fcompiler and to check which C compilers are available: python setup.py build --help-compiler","title":"Installation"},{"location":"install/#installation","text":"Helita needs Python 3.4.x or higher, use of Python 2.x is discouraged . Helita relies on several standard scientific python libraries. Here is a list of required and optional (not all functions will work) packages: Required Optional astropy cython NumPy numba SciPy bqplot xarray ipywidgets h5py matplotlib tqdm specutils Many of these should be installed when astropy is installed. All of the above Python packages are available through Anaconda , and that is the recommended way of setting up your Python distribution. Compiled modules Some helita modules are written in C and Fortran. To use them, you need to have respective compilers available in your system before you try to install helita (see below for help with compilers). The Fortran modules are optional, and most of helita works without them, but the C modules are not. You need a C compiler to install helita!","title":"Installation"},{"location":"install/#install-from-source","text":"To install helita you need to clone the repository (or download a zip version if you don't have git) and then install with python: git clone https://github.com/ITA-solar/helita.git cd helita python setup.py install","title":"Install from source"},{"location":"install/#non-root-install","text":"If you don't have write permission to your Python packages directory, use the following option with setup.py : python setup.py install --user This will install helita under your home directory (typically ~/.local ).","title":"Non-root install"},{"location":"install/#developer-install","text":"If you want to install helita but also actively change the code or contribute to its development, it is recommended that you do a developer install instead: python setup.py develop This will set up the package such as the source files used are from the git repository that you cloned (only a link to it is placed on the Python packages directory). Can also be combined with the --user flag for local installs.","title":"Developer install"},{"location":"install/#installing-with-different-c-or-fortran-compilers","text":"The procedure above will compile the C and Fortran modules using the default gcc/gfortran compilers. It will fail if at least a C compiler is not available in the system. If you want to use a different compiler, please use setup.py with the --compiler=xxx and/or --fcompiler=yyy options, where xxx , yyy are C and Fortran compiler families (names depend on system). To check which Fortran compilers are available in your system, you can run: python setup.py build --help-fcompiler and to check which C compilers are available: python setup.py build --help-compiler","title":"Installing with different C or Fortran compilers"},{"location":"usage/","text":"Example usage \u00b6 Loading Bifrost snapshots \u00b6 The bifrost module under helita.sim reads and manipulates the native output format from Bifrost simulations (not FITS). To load some data, do: from helita.sim import bifrost data = bifrost . BifrostData ( \"cb24bih\" , snap = 300 , fdir = '/data/cb24bih' ) The first argument to BifrostData() is the basename for file names (an underscore, the snapshot number, and file extensions will be added, e.g. cb24bih_300.snap ). The object data contains the data for a single snapshot, but when initialised no data is loaded into memory. Simple variables are available as a memmap. These are variables that do not require any transformation before being read (typically scalar variables at cell centres and vector variables at cell faces). A list of such variable names is kept at data.simple_vars , and can be accessed as data.variables[myvar] or data.myvar , e.g.: >>> data . tg . shape ( 504 , 504 , 496 ) >>> data . variables [ 'tg' ] is data . tg True The method get_var() can be used to read or extract any variable, including composite variables , which typically combine several simple variables and involve shifting variables from cell centres to cell faces or vice-versa. For example, to obtain velocities in the z direction: vz = data . get_var ( 'uz' ) By default, this velocity will be defined at cell faces. To instead obtain it at the cell centres, we need to manually shift the momentum in the z direction (with the cstagger utilities) and divide it by the density, e.g.: from helita.sim import cstagger rdt = data . r . dtype cstagger . init_stagger ( data . nz , data . dx , data . dy , data . z . astype ( rdt ), data . zdn . astype ( rdt ), data . dzidzup . astype ( rdt ), data . dzidzdn . astype ( rdt )) vz_cell_centre = cstagger . zup ( data . pz ) / data . r Converting Bifrost to RH 1.5D and Multi3D atmospheres \u00b6 The BifrostData object has methods to convert the output into different formats. For example, to save the data from a single snapshot to an input atmosphere for RH 1.5D: data = bifrost . BifrostData ( \"cb24bih\" , snap = 300 , fdir = '/data/cb24bih' ) data . write_rh15d ( 'myfile.hdf5' , desc = 'Some description' ) The interface also allows writing only part of the atmosphere using python slice objects in the x, y, and z dimensions. For example, to write every second point in the x and y directions, and the first 200 points in the z direction, you would do: sx = sy = slice ( None , None , 2 ) sz = slice ( 0 , 200 ) data . write_rh15d ( 'myfile.hdf5' , desc = 'Some description' , sx = sx , sy = sy , sz = sz ) An RH 1.5D atmosphere file can have multiple snapshots. To write additional snapshots to a file using the write_rh15d() method, you need to manually load a new snapshot and then use the append=True option (it can still be True for the first write, as long as the output file doesn't exist already). For example, writing snapshots from 100 to 150 to a single file: data = bifrost . BifrostData ( \"cb24bih\" , snap = 100 , fdir = '/data/cb24bih' ) for i in range ( 100 , 150 ): data . set_snap ( i ) data . write_rh15d ( 'myfile_s100-150.hdf5' , desc = 'Some description' , append = True ) Writing snapshots in Multi3D format is done similarly, but only one snapshot can be written by file. E.g.: data . write_multi3d ( 'myfile.atmos3d' , desc = 'Some description' ) The Multi3D interface also writes a mesh file (default name is mesh.dat ). Bifrost 2D to RH 1.5D \u00b6 RH 1.5D atmosphere files are always 3D, but the x and y dimensions can have a single element, meaning 1D and 2D geometries are possible. When converting 2D models from Bifrost to RH 1.5D, the resulting atmosphere will therefore have ny = 1 . However, when converting many 2D snapshots to RH 1.5D it is advantageous to save the temporal dimension as a y dimension, because RH 1.5D is not parallel in the temporal dimension. There is a function called bifrost2d_to_rh15d() in helita.sim.bifrost that does this. For example: import numpy as np snaps = np . arange ( 100 , 500 ) bifrost . bifrost2d_to_rh15d ( snaps , 'myfile2D.hdf5' , 'simroot' , 'mesh.dat' , '/path/to/simulation/' , desc = 'Some description' ) The resulting atmosphere variables will therefore have a shape of (1, nx, nt, nz) instead of (nt, nx, 1, nz) .","title":"Example usage"},{"location":"usage/#example-usage","text":"","title":"Example usage"},{"location":"usage/#loading-bifrost-snapshots","text":"The bifrost module under helita.sim reads and manipulates the native output format from Bifrost simulations (not FITS). To load some data, do: from helita.sim import bifrost data = bifrost . BifrostData ( \"cb24bih\" , snap = 300 , fdir = '/data/cb24bih' ) The first argument to BifrostData() is the basename for file names (an underscore, the snapshot number, and file extensions will be added, e.g. cb24bih_300.snap ). The object data contains the data for a single snapshot, but when initialised no data is loaded into memory. Simple variables are available as a memmap. These are variables that do not require any transformation before being read (typically scalar variables at cell centres and vector variables at cell faces). A list of such variable names is kept at data.simple_vars , and can be accessed as data.variables[myvar] or data.myvar , e.g.: >>> data . tg . shape ( 504 , 504 , 496 ) >>> data . variables [ 'tg' ] is data . tg True The method get_var() can be used to read or extract any variable, including composite variables , which typically combine several simple variables and involve shifting variables from cell centres to cell faces or vice-versa. For example, to obtain velocities in the z direction: vz = data . get_var ( 'uz' ) By default, this velocity will be defined at cell faces. To instead obtain it at the cell centres, we need to manually shift the momentum in the z direction (with the cstagger utilities) and divide it by the density, e.g.: from helita.sim import cstagger rdt = data . r . dtype cstagger . init_stagger ( data . nz , data . dx , data . dy , data . z . astype ( rdt ), data . zdn . astype ( rdt ), data . dzidzup . astype ( rdt ), data . dzidzdn . astype ( rdt )) vz_cell_centre = cstagger . zup ( data . pz ) / data . r","title":"Loading Bifrost snapshots"},{"location":"usage/#converting-bifrost-to-rh-15d-and-multi3d-atmospheres","text":"The BifrostData object has methods to convert the output into different formats. For example, to save the data from a single snapshot to an input atmosphere for RH 1.5D: data = bifrost . BifrostData ( \"cb24bih\" , snap = 300 , fdir = '/data/cb24bih' ) data . write_rh15d ( 'myfile.hdf5' , desc = 'Some description' ) The interface also allows writing only part of the atmosphere using python slice objects in the x, y, and z dimensions. For example, to write every second point in the x and y directions, and the first 200 points in the z direction, you would do: sx = sy = slice ( None , None , 2 ) sz = slice ( 0 , 200 ) data . write_rh15d ( 'myfile.hdf5' , desc = 'Some description' , sx = sx , sy = sy , sz = sz ) An RH 1.5D atmosphere file can have multiple snapshots. To write additional snapshots to a file using the write_rh15d() method, you need to manually load a new snapshot and then use the append=True option (it can still be True for the first write, as long as the output file doesn't exist already). For example, writing snapshots from 100 to 150 to a single file: data = bifrost . BifrostData ( \"cb24bih\" , snap = 100 , fdir = '/data/cb24bih' ) for i in range ( 100 , 150 ): data . set_snap ( i ) data . write_rh15d ( 'myfile_s100-150.hdf5' , desc = 'Some description' , append = True ) Writing snapshots in Multi3D format is done similarly, but only one snapshot can be written by file. E.g.: data . write_multi3d ( 'myfile.atmos3d' , desc = 'Some description' ) The Multi3D interface also writes a mesh file (default name is mesh.dat ).","title":"Converting Bifrost to RH 1.5D and Multi3D atmospheres"},{"location":"usage/#bifrost-2d-to-rh-15d","text":"RH 1.5D atmosphere files are always 3D, but the x and y dimensions can have a single element, meaning 1D and 2D geometries are possible. When converting 2D models from Bifrost to RH 1.5D, the resulting atmosphere will therefore have ny = 1 . However, when converting many 2D snapshots to RH 1.5D it is advantageous to save the temporal dimension as a y dimension, because RH 1.5D is not parallel in the temporal dimension. There is a function called bifrost2d_to_rh15d() in helita.sim.bifrost that does this. For example: import numpy as np snaps = np . arange ( 100 , 500 ) bifrost . bifrost2d_to_rh15d ( snaps , 'myfile2D.hdf5' , 'simroot' , 'mesh.dat' , '/path/to/simulation/' , desc = 'Some description' ) The resulting atmosphere variables will therefore have a shape of (1, nx, nt, nz) instead of (nt, nx, 1, nz) .","title":"Bifrost 2D to RH 1.5D"}]}